# 自动化的界限在哪里？

用休假录入助手为例子。

它干的事很简单：从Excel复制一堆休假数据过来，脚本自动解析员工号、休假类型、日期，然后一条一条帮你把表单填好、点下一步、检查结果。

没冲突？自动继续下一条。
有冲突？停下来，把冲突信息显示出来，等你决定怎么办——跳过、重试、还是先不管了。

为什么不让它直接全自动处理完？

---

## 自动化的前提：数据要规范

脚本能自动解析数据，前提是数据格式统一、结构规范。

配套的休假表模板是这样设计的：

**整体结构：**
- 12个工作表，每月一个（1月休假申请 ~ 12月休假申请）
- 每个工作表分三个区域：一分部（A-I列）、二分部（K-S列）、三分部（U-AC列）
- 第1行是分部标识（合并单元格）
- 第2行是表头
- 第3行是示例数据
- 第4行开始是实际数据

**每个分部的列结构：**
| 列 | 内容 | 说明 |
|---|---|---|
| 序号 | 已预填 | 自动编号 |
| 员工号 | 已预填 | 6位数字 |
| 姓名 | 已预填 | 从花名册导入 |
| 请假类型 | 用户填写 | 下拉框选择 |
| 开始日期 | 用户填写 | 格式如 2026-01-15 |
| 结束日期 | 用户填写 | 格式如 2026-01-15 |
| 休假天数 | 自动计算 | 公式：`=IF(OR(E4="",F4=""),"",F4-E4+1)` |
| 锁班状态 | 标记用 | 记录处理进度 |
| 备注 | 可选 | 补充说明 |

**设计要点：**

1. 员工号和姓名预填好，用户只需要填请假类型和日期，减少出错
2. 请假类型用下拉框，格式统一（如 `ALV_FD-飞行员公休（订座）`），和程序里的映射一致
3. 日期格式固定，脚本用正则 `\d{4}[-/]\d{1,2}[-/]\d{1,2}` 就能匹配
4. 从Excel复制出来的文本，每行都是"员工号 姓名 请假类型 开始日期 结束日期"的结构

如果数据格式乱七八糟，脚本根本没法解析。自动化的第一步，是把数据源头规范化。

---

填表这件事，对每个人都是一样的：

1. 输入员工号
2. 选休假类型
3. 填开始日期
4. 填结束日期

流程固定，步骤重复，数据不同而已。这种活儿让脚本干，又快又准，基本不出错。

但点完"下一步"之后，系统会检查这条记录有没有问题。

没问题当然好，脚本直接帮你点"继续录入"，进入下一条。

问题是，经常会有冲突。

冲突的原因五花八门：日期和别的安排撞了，或者其他莫名其妙的提示。每个人的情况都不一样，该怎么处理也完全不同。

这时候脚本就没法替你做主了。

它能做的，就是把冲突信息摆在你面前，然后等你说一声：跳过，还是重试，还是先算了。

---

所以界限就在这里：

**能预测、完全重复的步骤** → 脚本来干，省时间、不出错。

**因人而异、需要判断的情况** → 留给人，安全、靠谱。

自动化不是越全越好。卡在"人机分工最舒服"的地方，才是最靠谱的设计。

机器干苦力，人做决策。


---

## 程序设计

整个脚本用Python写，依赖Playwright做浏览器自动化，Colorama做终端彩色输出。

### 休假类型映射

程序开头定义了一个字典 `LEAVE_TYPE_MAP`，把中文的休假类型名称映射到系统里的代码：

```python
LEAVE_TYPE_MAP = {
    "ALV_FD-飞行员公休（订座）": "ALV_FD",
    "ALV-年假（公休假）": "ALV",
    "RECU_LVE-健康疗养": "RECU_LVE",
    "RECU_LVE_R-康复疗养": "RECU_LVE_R",
    "MAT_FA_LVE-陪产假": "MAT_FA_LVE",
    "PARENT_LVE-探亲假-探父母": "PARENT_LVE",
    "SPOUSE_LVE-探亲假-探配偶": "SPOUSE_LVE",
    "MARR_LVE-婚假": "MARR_LVE",
    "COMP_LVE-丧假": "COMP_LVE",
    "CHILD_LVE-育儿假": "CHILD_LVE",
}
```

从Excel复制过来的文本里会包含完整的类型名称（比如"ALV_FD-飞行员公休（订座）"），程序遍历这个字典，找到匹配的就取对应的代码填到表单里。

### 数据解析

`parse_single_record` 函数负责从一行文本里提取所有需要的信息：

```python
def parse_single_record(text: str) -> dict:
    result = {"员工号": None, "姓名": None, "请假类型": None, "开始日期": None, "结束日期": None}
    # 用正则匹配6位数字作为员工号
    emp = re.search(r'\b(\d{6})\b', text)
    if emp:
        result["员工号"] = emp.group(1)
    # 员工号后面紧跟的2-4个中文字符作为姓名
    name = re.search(r'\d{6}\s*([\u4e00-\u9fa5]{2,4})', text)
    if name:
        result["姓名"] = name.group(1)
    # 遍历类型映射，找到匹配的休假类型
    for key, val in LEAVE_TYPE_MAP.items():
        if key in text:
            result["请假类型"] = val
            break
    # 提取日期，支持2025-01-05和2025/1/5两种格式
    dates = re.findall(r'\d{4}[-/]\d{1,2}[-/]\d{1,2}', text)
    if dates:
        result["开始日期"] = normalize_date(dates[0])
        result["结束日期"] = normalize_date(dates[1]) if len(dates) > 1 else normalize_date(dates[0])
    return result
```

`normalize_date` 函数把日期统一转成 `YYYY-MM-DD` 格式，月和日不足两位的补零。

`parse_batch_input` 处理批量输入：按换行切分成多行，逐行调用 `parse_single_record`，同时过滤白名单、收集解析错误。如果粘贴的是一整行没有换行的长文本（统信系统有时候会这样），它会尝试按员工号切分。

### 表单填写

`fill_form` 函数操作浏览器填写表单：

```python
def fill_form(page, emp_id, leave_type, start_date, end_date):
    clear_form(page)  # 先清空表单
    
    # 输入员工号
    emp_input = page.locator("#showIdshowNonproductionTaskImportPage")
    emp_input.click()
    emp_input.fill("")
    emp_input.type(str(emp_id), delay=50)  # 模拟逐字输入
    # 触发blur和change事件，让系统自动带出姓名
    page.evaluate("""
        const input = document.querySelector('#showIdshowNonproductionTaskImportPage');
        if (input) {
            input.dispatchEvent(new Event('blur', { bubbles: true }));
            input.dispatchEvent(new Event('change', { bubbles: true }));
        }
    """)
    
    # 设置下拉框的值
    # 因为是Vue框架，直接设value不会生效，必须触发一系列事件
    page.evaluate("""(leaveType) => {
        const select = document.querySelector('#lockType');
        if (select) {
            select.focus();
            select.value = leaveType;
            select.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
            select.dispatchEvent(new MouseEvent('click', { bubbles: true }));
            select.dispatchEvent(new Event('input', { bubbles: true }));
            select.dispatchEvent(new Event('change', { bubbles: true }));
            select.dispatchEvent(new Event('blur', { bubbles: true }));
        }
    }""", leave_type)
    
    # 填入日期
    page.locator("#lockStartTime").fill(start_date)
    page.locator("#lockEndTime").fill(end_date)
```

这里有个坑：系统是Vue写的，下拉框不能直接设置value，必须用JS触发mousedown、click、input、change、blur一整套事件，框架才会响应。

### 提交与冲突检测

`submit_and_check` 函数是整个程序的核心判断逻辑：

```python
def submit_and_check(page):
    # 点击下一步
    page.get_by_role("button", name="下一步").click()
    # 等待结果页面加载完成（继续录入按钮出现说明加载完了）
    page.get_by_role("button", name="继续录入").wait_for()
    
    # 检查查询结果表格
    result_rows = page.locator("#showNonproductionTaskImportResultPage1 tbody.list tr")
    # 检查冲突列表
    conflict_rows = page.locator("#showNonproductionTaskImportResultPage2 tbody.list tr")
    conflict_text = ""
    if conflict_rows.count() > 0:
        conflict_text = conflict_rows.first.inner_text()
    
    # 判断成功条件：查询结果有数据 且 冲突列表显示"没有相关信息"
    if result_rows.count() > 0 and "没有相关信息" in conflict_text:
        # 没冲突，自动点继续录入，进入下一条
        page.get_by_role("button", name="继续录入").click()
        page.locator("#showIdshowNonproductionTaskImportPage").wait_for()
        return True, None
    else:
        # 有冲突，返回冲突信息
        if result_rows.count() == 0:
            conflict_info = "查询结果为空"
        else:
            conflict_info = conflict_text
        return False, conflict_info
```

这就是自动化的界限所在：
- 没冲突 → 返回 `True`，程序自动继续下一条
- 有冲突 → 返回 `False` 和冲突信息，程序暂停，等人决定

### 批量模式主循环

`batch_mode` 函数是批量处理的主流程：

1. 提示用户粘贴数据
2. 调用 `parse_batch_input` 解析，显示识别出的记录列表
3. 用户输入 `y` 确认后，开始逐条处理
4. 每条记录：调用 `fill_form` 填表 → 调用 `submit_and_check` 提交检查
5. 如果成功，打印"提交成功"，继续下一条
6. 如果失败，打印冲突信息，等待用户输入：
   - `s`：跳过这条，记录到失败列表，继续下一条
   - `r`：重试当前这条
   - `b`：返回主菜单
7. 全部处理完后，打印失败记录汇总

```python
while i < len(records):
    record = records[i]
    fill_form(page, record["员工号"], record["请假类型"], record["开始日期"], record["结束日期"])
    success, conflict_info = submit_and_check(page)
    if success:
        print("提交成功")
    else:
        print("有冲突!")
        print(conflict_info)
        cmd = input("s跳过,r重试,b返回主菜单: ")
        if cmd == 's':
            failed_records.append((record, "有冲突"))
            i += 1
        elif cmd == 'r':
            continue  # 不增加i，重试当前记录
        elif cmd == 'b':
            return
    i += 1
```

### 白名单

程序支持预设白名单。启动时可以粘贴一批员工号，之后只处理白名单内的人，其他自动跳过。

`parse_whitelist` 函数从文本里提取所有6位数字作为员工号集合。解析数据时，如果员工号不在白名单里，直接跳过不处理。

这个功能适合只需要处理特定几个人的场景，比如只处理某个班组的休假。

### 启动流程

`main` 函数是程序入口：

1. 询问浏览器路径（可以指定本地浏览器，比如统信系统的 `/usr/bin/browser`）
2. 询问是否预设白名单
3. 启动Playwright，打开浏览器
4. 自动跳转到登录页，等待扫码登录
5. 登录成功后自动导航到"运行管理 → 非生产任务 → 非生产任务录入"页面
6. 进入主菜单循环：选择批量模式、手动模式、设置白名单、退出
